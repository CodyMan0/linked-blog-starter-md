---
aliases: []
tags : 
---
Up : [[knowledge_MOCs]]

출처 :
저자 : 태오
URL : https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94#%ED%94%84%EB%A1%A4%EB%A1%9C%EA%B7%B8
인용 : 




Q. 확장성있는 서비스를 만들기 위해서는 어떻게 해야할까? 
Q. 클론 코딩으로 진행한 기본적인 코드에서 잘만든 코드로 결합해서 실행되도록 하려면 어떻게 해야할까? 

아키텍처는 옷장이다. 
결국 실제 만든 소프트웨어가 지속적으로 관리가 잘되는 코드로 유지하려면 좋은 아키텍쳐가 필요하다는 것. 
유지보수하기 좋은 아키텍쳐로 수정하는 것은 유저에게 보이지 않은 일이지만 장기적인 관점에서는 중요하다. 


## 고전인 MVC 아키텍쳐 
- view는  화면 (HTML , CSS, JS로 만들어지는 결과물)
- model은 데이터를 주관하는 영역 하지만 아키텍쳐에 따라서 javascript의 Object일 수도 있고,  서버의 API로 받는 데이터일수도 있고,  서버에 있는 DB일 수도 있습니다.
중요한 건 프로그램이 다루는 중요한 데이터 영역이라는 것. 
- controller는 Model(data)와 유저의 action 사이 중간 역할을 Controller라고 한다. 

### 그럼 MVC가 나눠진 이유
1. UI 와 Data 영역의 관심사를 분리하고자 함.

## 초창기 웹 서비스의 MVC 아키텍처 
과거 웹 서비스 초창기의 MVC는 
- Model : DB
- View : HTML , css , js
- Controller : router로 데이터를 철하고 새로운 HTML을 만들어서 보여주는 부분


## jQuery에서의 MVC 아키텍쳐 
[[ajax]]라는 기술로 말미암아 HTML을 서버에서 만들 필요가 없게 됐다. 그로인해서 기존에 정의했던 MVC의 역할이 모호해지게 됐다.
- ajax로 서버로 부터 받는 데이터를 Model로 취급.
- HTML, CSS로 만들어지는 화면 View
- JS로 서버 데이터를 받아서 화면을 바꾸고 유저와의 인터렉션을 통해 서버 데이터를 전달하는게 Controller의 역할을 수행하게 됐다. 

## 지금의 MVVM 아키텍쳐 
jQuery, 다소 명령적인 프로그래밍인 단점으로 인해 선언적인 프로그래밍을 할 수 있는 도구가 없을까라는 고민이 나왔던 시기 

왜 MVVM 아키텍쳐라고 할까? 
-> jQuery의 단점인 직접 개발자가 돔에 접근하여 수정되는 데이터를 view에 반영해야했던 것을 기억할 겁니다. 하지만 angular , Vue, React는 프레임 워크의 내부에 돔에 접근하는 코드와 방법이 가리워져있습니다. 그렇다보니 개발자는 변경되는 데이터와 View만 신경을 쓰면 됐습니다. 

## 컴포넌트 주도 개발 그리고 Container-Presenter 패턴
MVVM 을 통해서 DOM API를 잘 다루지 못해도 비지니스 로직에만 집중하면 빠르게 서비스를 만들 수 있는 시대가 됐다. 웹페이지의 성장으로 이제 기본적인 단위가 페이지가 아닌 컴포넌트로 발전하게 됐다. 컴포넌트에는 비지니스 로직이 포함되지 않도록 했다. 왜냐하면 로직이 포함되면 재사용성이 떨어지기 때문. 

그래서 비지니스 로직을 관장하고 있는 컴포넌트를 Container , 로직이 없고 데이터를 들어온 데이터를 내려주는 Presenter 아키텍쳐로 만들게 됐다. 
하지만 이렇게 사용하다보니 Props Drilling이라는 문제가 화두됐다. 그도 그럴것이 서비스가 커지면서 컴포넌트의 갯수와 계층이 커져만 갈텐데 그때 만약 서로 멀리 떨어져있는 컴포넌트에게 데이터를 보내고 싶을때 어떻게 해야했을까.. 상태를 끌어올리거나 데이터를 내려줬을텐데 그렇게 되면 불필요한 렌더링이 발생하게 된다. 이것을 해결하고자 facebook
은 FLUX 패턴과 Redux를 사용하게 됐다.

## FLUX 패턴과 Redux
MVC의 양방향 패턴에서 단방향 아키텍처로 변화의 바람이 불었다. 
FLUX 패턴은 단일한 흐름을 취한다 

View에서 Action을 호출하면 Dispatcher를 통해서 Store라는 공간에 데이터가 보관이 되고 View로 전달이 되는 흐름

## FLUX 패턴의 한계 
1. 높은 러닝 커브
2. 어려운 문법


## Observer-Observable Pattern





### 생각의 연결고리
분야 :

키워드 :

관련있는 메모 :

