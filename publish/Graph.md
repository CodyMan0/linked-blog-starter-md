## 사전 지식 : stack, queue , recursive function
stack : 선입 후출 구조 혹은 후입 선출 구조이다.  파이썬에서는 append와 pop 매소드가 동일하게 리스트의 말미에서 데이터를 삽입하고 삭제하기에 별다른 라이브러리를 사용할 필요가 없다. 

queue:  선입 선출의 구조. 파이썬에서 큐를 구현하기 위해 deque라는 라이브러리를 사용할 수 있다. 핵심은 삽입과 삭제를 각각 다른 위치에서 시켜주면 되는 것. 

resursive function : 자기 자신을 호출하는 함수로 기저 조건을 필히 기입해야한다. 
- 예제  : 팩토리얼 구현하기
```python
# 탑 다운
def factorial_iterative(n):
	result = 1
	for i in range(1, n + 1)
		result *= i
	return result
# 바텀 업
def  factorial_iterative(n):
	if n <= 1:
	return 1
	return n * factorial_iterative(n - 1):

```

반복문의 방식보다 재귀함수를 사용했을때 코드가 더 간결해진다. 하지만 스택을 많이 차지하므로 성능에 좋지 않을때도 있다는 점 기억하자. 




## 그래프란 

특정조건을 만족하는 [[Tree]]는 그래프의 한 종류 

### 특정 조건 
1. 연결되지 않은 노드가 없어야한다. 
2. 사이클이 있으면 안된다.

## 두가지 표현 방식
- 인접 행렬 : 인접행렬 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식으로 2차원 리스트를 이용한다./ 연결되어 있지 않은 노드끼리는 무한의 비용이라고 작성한다

    필요없는 노드관계도 다 저장해, 노드 개수가 많을 수록 메모리가 낭비
    
```python
INF=99999999999
graph=[[0,7,5],[7,0,INF],[5,INF,0]]
print(graph)

- 인접 리스트

## 그래프 용어
1. 정점 : 트리의 노드를 말함. 
2. 간선 : edge 정점끼리 연결하는 선 
3. 이웃 : 가까운 정점끼리 
4. 방향 그래프 : 양방향으로 관계를 표현하는 그래프! 


## 그래프


1.  
    
```

- 인접리스트 : 리스트자료형을 이용해 기록하는 방식으로 연결된 노드 정보만 (노드,거리)로 전달한다. 인접행렬에 비해 메모리가 효율적이지만, 특정 두 노드가 연결되어있는지 확인하는데 오래걸려 따라서, 특정노드에 연결된 모든 인접 노드를 순회해야하는 경우 인접 리스트 방식이 인접행렬보다 메모리 낭비가 적다.
```python
graph=[[] for _ in range(3)]

#노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1,7))
graph[0].append((2,5))

#노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0,7))

#노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0,5))

print(graph)
```



## 그래프를 탐색하는 방법 

1. 깊이 우선 탐색 :  [[Depth First Search]]
2. 너비 우선 탐색 : [[Breadth First Search]]

