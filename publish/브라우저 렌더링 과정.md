대부분의 프로그래밍 언어는 [[OS Moc]] 혹은 VM 위에서 실행되지만, 웹 application은 [[client side]] JS는 브라우저에HTML, CSS와 함께 실행된다. 따라서 **브라우저 환경**을 고려해야한다.

-> 브라우저 환경을 고려한다는 것은 브라우저 렌더링 과정을 이해하는것 [[critical rendering path]]

- 파싱 
- 렌더링 : HTML,CSS,JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 의미

렌더링 과정 
1. HTML,CSS,JS,이미지,폰트 파일등 렌더링에 필요한 리소스를 서버로 부터 응답
2. 브라우저의 렌더링 엔진이 응답된 HTML과 CSS를 파싱해서 DOM과 CSSOM을 만들고 결합해서 render tree를 만든다.
3. 브라우저의 JS 엔진은 서버로 부터 받은 JS를 파싱해서 AST를 생성하고 바이트 코드로 변환하여 실행한다. 이때 자바스크립트 DOM API를 통해서 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM ,CSSOM은 다시 렌더 트리로 결합된다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다. 

## 요청과 응답
브라우저의 핵심 기능 : 리소스를 서버에 요청하고 응답받아 브라우저에 렌더링해주는 것. 
### 데이터 요청 및 응답 방법 
1.  주소창을 통해서 정적 파일 요청
2. JS를 통해 동적으로 서버에서 데이터를 요청할 수도 있다. 

## HTTP 1.1과 HTTP 2.0
http는 웹에서 브라우저와 서버가 통신을 하기 위한 Protocol. 

http1.1은 커넥션당 하나의 요청과 응답
http2.0은 두가지 요청과 두가지 응답을 받을 수 있다. 


## HTML 파싱과 DOM 생성
택스트를 브라우저에 시각적인 픽셀로 렌더링을 위해서는 브라우저가 이해할 수 있는 자료구조로 변환해서 메모리에 저장해야한다. 그게 DOM이다. 다시 말해 DOM이란 HTML 택스트를 브라우저에 렌더링을 하기 위해 브라우저가 지정한 자료구조라고 정리해볼 수 있다. 

### DOM 생성 과정
- 서버
1. 바이트 : 브라우저가 요청한 HTML을 메모리에 저장된 바이트를 인터넷을 경유하여 응답한다.
- 클라이언트 
2. 문자 : HTML 문서는 meta태크의 charset 속성에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환
3. 토큰 : 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소단위 **토큰**으로 분해
4. 노드 : 각 토큰들을 객체로 변환하여 노드를 생성. 토큰의 내용에 따라 document node, element node, attribute node, text node가 형성된다. 
5. DOM : HTML의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이것을 DOM이라고 한다.

### CSS 파싱과 CSSOM 생성
브라우저 렌더링 엔진은 HTML을 동기적으로 파싱하여 DOM을 생성하다가 CSS를 로드하는 link,style 태그를 만나면 DOM 생성을 중단한다. 그리고 HTML과 동일한 과정인 (바이트 -> 문자 -> 토큰 -> 노드-> CSSOM)을 해석해서 쏨트리를 생성, 완료되면 다시 DOM 생성시 중단됐던 지점부터 파싱하여 DOM을 완성시킨다. 
연관 : [[CSS]] 

### 렌더 트리 생성
- 렌더 트리 생성
렌더링을 위해서 DOM과 CSSOM을 결합하여 render tree로 만들어진다. 브라우저 렌더링을 위해서 지정된 자료
구조는 **RENDER tree**

- layout 위치 크기 조절

- painting 입력에 자리 잡는다.
렌더트리가 완성된 후, HTML요소의 레이아웃(위치와 크기)를 계산하는데 사용되고 브라우저 화면에 렌더링하는 페인팅 처리에 입력된다.

-> layout 계산과 painting을 반복하는 리렌더링은 성능에 악영향을 미친다. 

### 자바스크립트 파싱과 실행
DOM은 HTML문서의 구조만이 아닌 프로그래밍 interface인 DOM API를 제공한다. 즉 자바스크립트 코드에서 DOM이 제공해준 API를 사용하면 이미 생성된 DOM을 조작할 수 있다. 

HTML,CSS 파싱과 동일하게 DOM을 생성하다가 script 태그를 만나면 DOM 생성을 중단하고 script의 src의 서버에 요청을 하여 자바스크립트를 받아온다. 이때 자바스크립트 코드를 파싱하기 위해 **제어권**이 렌더링 엔진에서 V8 엔진으로 넘어간다. 자바스크립트 파싱과 실행이 종료되면 다시 렌더링 엔진으로 제어권이 넘어가고 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다. 

자바스크립트 파싱, 실행은 전적으로 자바스크립트 엔진이 처리한다. 자바스크립트 코드를 파싱하기 위해서 Low-level-language로 변환하고 실행하는 역할을 수행한다. 

자바스크립트를 해석하여 AST(추상적 구문트리)를 생성한다. AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트 코드를 생성하여 실행한다. 

![[스크린샷 2023-04-21 오후 3.46.38.png]]

- 어휘 분석
-> 토크 나이징 : 단순한 문자열을 분석하여 문법적 의미를 갖는 최소단위인 토큰으로 분해
- 구문 분석
-> 토큰들의 집합을 AST를 생성. AST를 사용하면 TS,Babel,Prettier 같은 트랜스파일러를 구현할 수 있다.
-> AST가 인터프리터가 실행할 수 있는 바이트 코드로 변환되고 인터프리터에 의해 실행


### 리플로우와 리페인트
DOM API에 의해 이전에 만들어진 DOM과 CSSOM이 변경되어 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거져 리렌더링한다. 이를 reflow, repaint라고 한다. 


### 자바스크립트 파싱에 의한 HTML 파싱 중단
브라우저는 동기적으로 HTML,CSS, JS를 파싱하는데 이로 인해 HTML의 돔트리가 무거운 연산이 들어있는 JS에 의해 다소 늦게 돔이 완성될 경우가 있다. 그렇게 된다는 것은 사용자가 서버에 html을 요청하고 오랜 기간이 지난 후에나 페이지를 볼 수 있다는 것인데... 이를 해결 할 수 있는 방법은 없을까?

#### script의 위치 설정
1. body 최하단 -> 지나온 body 태그들을 이미 DOM에 생성했기에 JS에서 태그들을 인식할 수 있다. 
2. HTML5부터 생긴 async -> HTML파싱과 외부 파일 로드를 비동기적으로 진행. 단 파싱과 실행할떄는 DOM을 잠시 중단하고 완료후 돔이 다시 생성된다. 여러개의 script에 async 속성을 넣는다고 가정한다면 async 속성은 로드되는 순서에 의해 파싱되고 실행되기에 순서가 보장되지 않는다. 
3. defer 속성 -> async와 마찬가지로 로드를 비동기적으로 진행한다. DOM이 생성된 직후 JS가 파싱하고 실행한다. 또한 순서도 보장된다. 



