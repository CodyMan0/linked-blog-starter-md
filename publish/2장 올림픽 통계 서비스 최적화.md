# 2장 정리 

## 중요 포인트
1. CSS 애니메이션 최적화
2. 컴포넌트 지연 로딩
3. 컴포넌트 사전 로딩
4. 이미지 사전 로딩

### 컴포넌트 지연 로딩
1장을 통해 아주 조금 소개 됐다. react안에서 동적 Import를 통해 구현됐는데 이번에도 마찬가지로 코드 자체를 분할하는 것이 아닌 컴포넌트를 분할하여 컴포넌트가 사용되는 시점에 import 되도록한다.

#Q 모달 어떻게 구현하는지? 
1. Portal? 
2. hook? 
3. root에 놓고 라이브러리 방식
4. html로 dialog로 만들기!?
5. headless UI?? , 가볍다? 
-> 





### 컴포넌트 사전 로딩 
컴포넌트 지연로딩은 첫 화면 로딩 성능을 최적화할 수 있지만 서비스를 이용하는 과정에 버벅거릴 수 있다는 단점이 있다. 
그래서 해당 코드가 필요한 시점이 아닌 살짝 빠르게 로드하여 지연 없이 사용할 수 있도록 컴포넌트를 사전 로딩하는 기법을 살펴볼 예정 

### 이미지 사전로딩 
이미지도 필요한 시점보다 먼저 다운로드하고 필요할때 바로 보여주도록 할 예정 


## 코드 분석에서 핵심
1. css 애니메이션을 width로 줄 경우, 브라우저의 원리를 알면 코드가 잘못됐다는 것을 알 수 있게 된다.
#Q 테이블 컴포넌트 어떻게 만드는지?
1. antd 사용해서? 
2. 다양한 변수가 많아 복잡한 부분이 있다.
-> 어떻게 구현하는지 공유하면 좋을 것 같다. 

## 애니메이션 최적화 
교제에서는 가로 막대가 늘어날때 부드럽지 않다고 하는데 왜 부드러운지 모르겠다. CPU 6x slowDown으로 설정해보니, 아주 살짝 끊기는 현상이 보이긴 한다. 

#Q react에서는 public에 놓거나 src안에서 asset에 놓는지?? 정확하게 
#Q 70p 모달 처음 mount될때 image가 업로드되어서야 슬라이더가 커지는데?? 
1. 예시 같은가? 
2. loading 인디케이터?
3. light-house에서 layout-shift가 있는 것으로 보아 나쁜 예시 같다.

#Q img 파일 규격은 어떻게 해요? 
대부분의 이미지는 url로 가지고 오는 것도 있지만, 파일명으로 가지고 있다. 

#Q SVG 사용 방법 (코드 or 다운로드)
-> 아이콘은 svg로 써야한다. 

 #Q JPG , PNG의 차이는? 
 png가 무손실 압축이라 같은 이미지일때 jpg보다 사이즈가 크다. 보통 풍경, 사람 이미지는 jpg 좋고 icon과 같은 엣지가 선명해야하는 것은 Png가 좋다.  

#Q apng가 뭔지 아시나요? 

#Q key Prop의 기본적인 역할이외에 또다른 역할을 아시나요? 
컴포넌트 트리의 위치에 따라 상태도 보존되는데 키 Props을 다르게 가지면 reset된다??

#Q key Prop에는 uuid를 사용하지 않고 Math.random()도 사용하지 않고 객체!

### 애니메이션의 원리 
배경 : [[브라우저 렌더링 과정]]
핵심적인 것은 일반적으로 사용하는 디스플레이는 60헤르츠이다. 즉 1초에 60장의 화면을 빠르게 보여준다는 의미. 그래서 브라우저도 이에 맞춰져있다.

#Q requestAnimationFrame을 사용해본 적이 있나요? 
-> 사용해본적이 없다.  주로 interactive한 것을 만든다. 

#Q 브라우저 렌더링 과정을 말씀해주세요
-> layout -> paint -> composite-> reflow -> repaint

#Q visibilty는 reflow? repaint ? 

#Q css의 레스터 개념이 뭐야? 

#Q 1px 몇 바이트니? 

#Q RGB 는 3바이트 RGBA 4바이트 Hex 바이트가 다른가? 리소스 측면에서 비교!? 
-> 색상 차이!? 미묘한데


#Q useEffect와 useLayoutEffect 차이


#Q useLayoutEffect는 언제 사용할까? 
-> 데이터 패칭을 빠르게 하고 싶을때? 
-> 업데이트하고 돔에 접근할 필요가 있을때
-> 과게에는 돔 조작을 위해 사용했지만 렌더링 된 이후에 동작하지 않는 에럭 ㅏ있었고 페인트 전에 관련된 동작을 사용했다. class일때는 많이 사용했다. 

#Q 그럼 현재는!? 어떻게 구현할 수 있을까? useLayoutEffect와 같은 것이 있나? 
-> react 18 발전돼, 필요가 없어졌다? class ->  funtion 

#Q vue.js  v-if / v-show 의 차이? 
v-show는 display : none , 

#Q 언제 v-if ? 언제 v-show ? v-hidden을 사용하는게 좋을까?

#Q 이벤트 핸들러 네단계?
Down -> Press -> onInput->  Up 
onKeyUp

#Q. onInput을 사용하면 좋은게? 
-> 사용자눈에는 keyUp 실제 value 바인딩되는 것은 onInput이다. 

#Q useEffect가 순서대로 호출이 되나? (이것도 함수니깐?)
-> 

#Q 마우스 이벤트의 차이를 아시나요?  (over, out) vs(enter/leave)
이벤트 버블링과 관련 

#Q. Synthetic event!???

브라우저 렌더링 과정을 간략하게 정리하면
1. 서버로부터 html,css 리소스 로드하여 파싱해서 DOM과 CSSOM을 만들고 합쳐서 렌더트리를 만든다. 만들어진 렌더트리로 각 요소의 레이아웃을 계산하는데 쓰인다.
2. 트리가 완성되면 화면에 구성되는 위치 크기 계산한다.
3. 계산이 끝나면 색을 채워넣는 과정이 진행된다.
4. 마지막으로 각 레이어를 합치는 과정이 있다. 

현재 예제를 살펴보면
1. Parse HTML 이후 reflow가 일어난다.

핵심 개념
1. **리플로우** : 렌더링 과정을 다시 실행하게 하는 것
2. **리페인트** : 배경색과 같은 색상 속성의 변경으로 레아아웃 이후 페인트와 합성 단계만 거치게 하는 것.

**중요**
리플로우와 리페인트를 해결하기 위해서 GPU를 이용하면 된다.
transform과 opacity와 같은 속성을 사용하면 된다, 
이런 속성은 브라우저 단에서 작업을 GPU로 위임해서 처리해서 레아아웃과 페인트 단계를 뛰어 넘을 수 있다. 이 개념을 **하드웨어 가속**이라고 한다.

#### 하드 웨어 가속
CPU가 GPU로 위임하여 처리하는 방법을 말한다. 

##### 애니메이션 성능에 도움 되는 것
transform과 opacity

> transform : translate()은 처음부터도 레이어를 분리하지 않고 변화가 일어나는 순간 레이어를 분리한다.
> transform : translate3d() 혹은 will-change 속성은 처음부터 분리해서 변화에 더욱 빠르게 대처할 수 있다. 

width로 애니메이션을 줄 경우
아래와 같이 계속 리플로우가 발생해서 정크 현상이 생긴다. 네트워크에 따라 끊길 수 있다,. 
![[스크린샷 2023-07-14 오후 3.30.44.png]]


##### 도움이 되지 않는 것
width, height, color

##### 문제 해결 방안
transform의 다양한 값 사용
위치 이동 시키는 translate, 
크기 변경 scale
요소 회전 : rotate 

```css
transform: scaleX(${({ width }) => width / 100});
transform-origin: center left;
```

팁 scale의 기준점은 항상 center라는 것 그래서 left로 옮겨야한다. 위와같이 

```css
	//전
    width: ${({width}) => width}%;
    transition: width 1.5s ease;
    
    //후
	width: 100%;
    transform: scaleX(${({width}) => width/100});
    transform-origin: center left;
    transition: transform 1.5s ease;
```

전
![[스크린샷 2023-07-14 오후 3.30.44.png]]
후
![[스크린샷 2023-07-14 오후 3.39.44.png]]



현재 step이라는 상태에 따라 프로그래스바를 구현하고 있습니다. 상위 컴포넌트에서 하위 컴포넌트로 step (string) 을 넘겨주고 tailwind를 활용하여 동적으로 class에 할당하기 위
해 객체를 만들어 props의 step 프로퍼티의 value를 넣어줘 구현하고 하고 있습니다.


### 컴포넌트 지연 로딩
#### 모달 코드 분리하기 

리액트 코드에서 suspense 와 lazy 함수를 활용하여 동적으로 import하여 컴포넌트 로딩을 지연하였다. 그래서 생긴 문제는 컴포넌트가 마운트될때 js를 로드해오기에 아래와 같이 약 1초에서 느리면 2초까지 아무일도 일어나지 않다가 모달이 뜨는 문제가 발생했다. 
![[스크린샷 2023-07-15 오전 11.38.36.png]]


### 컴포넌트 사전 로딩 
컴포넌트를 사전에 로딩할 수 있으면 좋겠다.

그럼 사전에 로딩하는 기점은 어떻게 선정할 것인지가 중요한 문제 그래서 책에서 추천하는 방식은 두가지가 있다. 첫번째는 유저가 해당 DOM에 mouse가 enter되었을때 파일을 로드하도록 하는것. 두번째는 컴포넌트가 마운트가 끝나면 그때 다른 파일을 로드하도록 하는 것.


#### 버튼 위에 마우스를 올려놓았을 때 로딩 
```ts
	const handleMouseEnter = () => {
		const component = import("./components/ImageModal");
	};

<button
	onMouseEnter={handleMouseEnter}
>
```

#### 컴포넌트의 마운트 완료 후 사전 로딩
```ts
useEffect(() => {
	const component = import("./components/ImageModal");
},[])
```
-> 너무 많이 쪼개도!? 좋지 않을 수 있다. 라우트별로 쪼개는 방식이 있다.

![[스크린샷 2023-07-15 오전 11.49.20.png|100]]
### 이미지 사전 로딩 
이미지는 화면에 그려지는 시점 즉 html 혹은 css에서 이미지를 사용하는 시점에 로드된다. Js를 활용하여 이미지를 직접 로드할 수 있는 방법이 있다. 바로 Image 객체를 사용하는 것.

chart.js를 사용할때 사용해본 경험이 있는데 프로젝트에 적용해보자


## 질문 정리! 

#Q css/js 뿐 아니라 브라우저에서도 script 태그로 할 수 있는데!?  다들 어떻게 하는지? 
wepack bundle하면 script tag에 defer가 붙어서 나온다. 
async는 웹 페이지와 관련없는 것들은 다 async 붙혀서 사용한다. 

#Q link에 rel attribute로 우선 순위 지정이 가능하다. 
다음 페이지 리소스 , 다운로드 도메인 미리 연결 시켜서 !?
font !? , css를 타고 
-> link 추가하는것!? 브라우저에게 힌트를 주는 것


#Q next.js에서 Script 태그 사용 경험을 공유해주세요. 



#Q AG GRID 라는게 있다!? 



## 프로젝트에 적용한 것

## 논의하고 싶은 것 정리 


